%=============================================================================%
% Author: 	John Joseph Valletta, Bram Kuijper
% Date: 	14/03/2017, 04/03/2019
% Title: 	Python workshop: flow control
%=============================================================================%

%=============================================================================%
% Preamble
%=============================================================================%
% Libraries

\documentclass[xcolor=table]{beamer}
\usepackage{beamerthemeshadow}
\usepackage{helvet}
\usepackage[]{graphicx}
\usepackage{array}
\usepackage{color}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{deepblue}{rgb}{0,0,0.5}
\definecolor{deepred}{rgb}{0.6,0,0}
\definecolor{deepgreen}{rgb}{0,0.5,0}
\definecolor{lightgray}{rgb}{0.92,0.92,0.92}
\usepackage{listings} % to insert code
\usepackage{textpos} % textblock
\usepackage{hyperref}
\hypersetup{colorlinks=true, urlcolor=blue, linkcolor=black} 
% Listing set up
% bash
\lstdefinestyle{bash}{
language=bash,                     % the language of the code
basicstyle=\scriptsize\ttfamily,       % the size of the fonts that are used for the code
numbers=none,%left,                   % where to put the line-numbers
numberstyle=\tiny\color{gray},  % the style that is used for the line-numbers
stepnumber=1,                   % the step between two line-numbers. If it's 1, each line
                          % will be numbered
numbersep=5pt,                  % how far the line-numbers are from the code
backgroundcolor=\color{lightgray},  % choose the background color. You must add \usepackage{color}
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
frame=lines,%single,                   % adds a frame around the code
rulecolor=\color{black},        % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. commens (green here))
tabsize=2,                      % sets default tabsize to 2 spaces
captionpos=b,                   % sets the caption-position to bottom
breaklines=true,                % sets automatic line breaking
breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
title=\lstname,                 % show the filename of files included with \lstinputlisting;
                          % also try caption instead of title
keywordstyle=\color{blue},      % keyword style
commentstyle=\color{dkgreen},   % comment style
stringstyle=\color{mauve},      % string literal style
escapeinside={\%*}{*)},         % if you want to add a comment within your code
morekeywords={}            % if you want to add more keywords to the set
}

% Python
\lstdefinestyle{python}{
language=python,
formfeed=\newpage,
basicstyle=\scriptsize\ttfamily,
commentstyle=\color{deepgreen},%\color{gray},
numbers=left,
numberstyle=\tiny\color{gray},
stepnumber=1,
numbersep=5pt,
backgroundcolor=\color{lightgray},%\color{white},
showspaces=false,
showstringspaces=false,
showtabs=false,
frame=lines,
tabsize=4,
captionpos=b,
breaklines=true,
breakatwhitespace=false,
title=\lstname,
escapeinside=||,
keywordstyle=\color{deepblue},
emphstyle=\color{deepred},
stringstyle=\color{deepgreen}
%morekeywords={models, lambda, forms}
}

\graphicspath{ {../img/} }
\title[Python for scientific research]{Python for scientific research}
\subtitle{Pattern matching and text manipulation}
\author{Bram Kuijper}
\institute[]{University of Exeter, Penryn Campus, UK}
\titlegraphic{
\hfill
\includegraphics[width=\textwidth, keepaspectratio]{logo.jpg}}
%=============================================================================%
%=============================================================================%
% Start of Document
%=============================================================================%
%=============================================================================%
\begin{document}

%=============================================================================%
%=============================================================================%
\begin{frame}
\titlepage
\end{frame}

%=============================================================================%
%=============================================================================%
\begin{frame}{What we've done so far}

	\begin{enumerate}\addtolength{\itemsep}{1\baselineskip}
		\item Declare variables using built-in data types and execute operations
		on them
		\item Use flow control commands to dictate the order in which commands are run
		and when
		\item Encapsulate programs into reusable functions, modules and packages
        \item \textbf{Next:} pattern matching and text manipulation
	\end{enumerate}

\end{frame}

%=============================================================================%
%=============================================================================%
\begin{frame}{Motivation}

\begin{itemize}\addtolength{\itemsep}{.5\baselineskip}
	\item<1-> Matching of patterns in text is a common programming task
	\item<2-> Some examples:
        \begin{itemize}\addtolength{\itemsep}{.25\baselineskip}
            \item<3-> Mining data for particular words or numbers (twitter feeds, abstracts, etc)
            \item<4-> Finding similar filenames, e.g., \texttt{data\_d01\_.csv}, \texttt{Data\_x102\_.xls}
            \item<5-> Converting datapoints from one format to another. E.g., dates \texttt{23.01.1980}, \texttt{230180} to \texttt{23-01-1980}
        \end{itemize}
    \item<6-> Solution: \textbf{regular expressions}
\end{itemize}

\end{frame}

%=============================================================================%
%=============================================================================%
\begin{frame}[fragile]
\frametitle{Finding patterns of text without regular expressions}
    \begin{itemize}
        \item Imagine one wants to convert various date formats to YYYY-MM-DD
\begin{lstlisting}[style=python]
s = "23.01.1980,08.09.1990,15-03-2019"

for i in range(0,len(s)):

    if i + 10 <= len(s):
        if s[i:i+2].isdigit() and s[i+2] in ".-" and s[i+3:i+5].isdigit() and s[i+5] in ".-" and s[i+6:i+10].isdigit():
            day = s[i:i+2]
            month = s[i+3:i+5]
            year = s[i+6:i+10]
            print(year + "-" + month + "-" + day)
\end{lstlisting}
\item Gets complicated quickly 
\item Breaks down for single digit months/days, e.g., \texttt{8.9.1980}
    \end{itemize}
\end{frame}

%=============================================================================%
%=============================================================================%
\begin{frame}[fragile]
\frametitle{Finding patterns of text with regular expressions}
\begin{lstlisting}[style=python]
# load the regular expression module
import re

# a string of text with dates (allowing for single digit days and months)
s = "23.01.1980,8.9.1990,15-03-2019"

# match with a regular expression (given as a r"" [raw literal] string)
all_dates = re.findall(r"(\d{1,2})[-\.](\d{1,2})[-\.](\d{4})",s)

# print 1980-01-23 etc
for date in all_dates:
    print(date[2] + "-" + date[1].zfill(2) + "-" + date[0].zfill(2))
\end{lstlisting}
\end{frame}
%=============================================================================%
%=============================================================================%
\begin{frame}[fragile]
\frametitle{What is a regular expression?}
    \begin{itemize}
        \item<1-> A tiny, highly specialized programming language within Python
        \item<2-> Made available in the \texttt{re} module
        \item<3-> Specifies the rules to match occurrences of patterns in text
        \item<4-> Allows you to modify text that matches a pattern (using \texttt{re.sub()})
        \item<5-> Provide a regular expression pattern as a string of text:
\begin{lstlisting}[style=python]
# specify a pattern that matches '3foo' but not 'foo'
regex_pattern = r"\dfoo"
\end{lstlisting}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Regular expressions: patterns}
    \begin{itemize}
        \item<1->\texttt{\textbackslash d} matches any character that is a digit
        \item<2->\texttt{\textbackslash D} matches any character that is not a digit
        \item<3->\texttt{\textbackslash s} matches any whitespace character (e.g., a space, a tab, a newline)
        \item<4->\texttt{\textbackslash S} matches any character that is not a whitespace
        \item<5->\texttt{\textbackslash b} matches a word boundary
    \end{itemize}
\end{frame}

%=============================================================================%
%=============================================================================%
\begin{frame}[fragile]
\frametitle{Regular expressions: functions}
    \begin{itemize}
        \item<1->\texttt{re.search(pattern, string [,flags])} Searches for \texttt{pattern} in \texttt{string}, return a
    \end{itemize}
\end{frame}

%=============================================================================%
%=============================================================================%
\begin{frame}[fragile]
\frametitle{List Comprehensions}

\begin{itemize}\addtolength{\itemsep}{0.5\baselineskip}

\item<1-> List comprehensions are an optimized and readible method for creating a list

\item<2-> Recall the previous example where we looped over gene names and printed them in upper
case
\begin{lstlisting}[style=python]
geneNames = ["Irf1", "Ccl3", "Il12rb1", "Ifng", "Cxcl10"]
for gene in geneNames:
    print(gene.upper())
\end{lstlisting}

\item<3-> What if I want to store the upper case gene names in another variable, 
called \texttt{x} for simplicity?

\end{itemize}

\end{frame}

%=============================================================================%
%=============================================================================%
\begin{frame}[fragile]
\frametitle{List Comprehensions}

\begin{enumerate}
\item<1-> Using for loops:
\begin{lstlisting}[style=python]
x = [] # create an empty list to append to
for gene in geneNames:
    x.append(gene.upper())
\end{lstlisting}

\item<2-> Using list comprehension:
\begin{lstlisting}[style=python]
x = [gene.upper() for gene in geneNames]
\end{lstlisting}

\item<3-> What if I want to ignore gene \texttt{Ifng}?
\begin{lstlisting}[style=python]
x = [gene.upper() for gene in geneNames if gene != "Ifng"]
\end{lstlisting}

\end{enumerate}

\end{frame}

%=============================================================================%
%=============================================================================%
\begin{frame}[fragile]
\frametitle{Enumerate}

\begin{itemize}\addtolength{\itemsep}{0.5\baselineskip}
\item<1-> When looping over lists, sometimes it's useful to keep track of the
index of the iteration

\item<2-> \textbf{Enumerate} is a built-in function that lets us access the
iterable element but also its index

\item<3-> Print the index next to upper cased gene name

\begin{enumerate}\addtolength{\itemsep}{-1\baselineskip}

\item<3-> Using a standard for loop:
\begin{lstlisting}[style=python]
i = 0 # index counter
for gene in geneNames:
    print("{0}. {1}\n".format(i+1, gene.upper()))
    i = i + 1
\end{lstlisting}

\item<4-> Using \texttt{enumerate}:
\begin{lstlisting}[style=python]
for i, gene in enumerate(geneNames):
    print("{0}. {1}\n".format(i+1, gene.upper()))
\end{lstlisting}

\end{enumerate}
\end{itemize}

\end{frame}

%=============================================================================%
%=============================================================================%
% End of Document
%=============================================================================%
%=============================================================================%
\end{document}
